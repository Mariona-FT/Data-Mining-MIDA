# -*- coding: utf-8 -*-
"""Activitat1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rmPGkR40GxWhFbqq3yS6xBOfxPBn30OW

#ACTIVITAT 1
Avaluació en un conjunt de dades de la borsa
"""

import pandas as pd
import numpy as np
from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt

from sklearn.cluster import KMeans

#carregar dades del DRIVE
from google.colab import drive

#from google.colab import drive -demana permis a llegir el DRIVE
drive.mount('/content/drive')
data_ag = pd.read_csv('drive/My Drive/MIDA/company-stock-movements-2010-2015-incl.csv',sep=',')


print(data_ag.shape)
data_ag.head()

#Crear set de dades
#No calen noms de les empreses
data_ag = data_ag.drop(['Unnamed: 0'], axis=1)

data_float = data_ag.astype(float).T

#inicalitzar
Xa = []
Ya = []

# Bucle per cada companyia
for company in data_float.columns:
    # Bucle per el dataframe amb la finestra de 6DIES
    for i in range(len(data_float) - 6):
        Xa.append(data_float[company].iloc[i:i+5].values)  # 5 DIES
        Ya.append(data_float[company].iloc[i+5])          # 6 DIES
Xa = np.array(Xa)
Ya = np.array(Ya)
print(Xa.shape)

import numpy as np
frac = 0.4  # Change 0.1 to the fraction you desire

indices = np.random.choice(Xa.shape[0], size=int(Xa.shape[0] * frac), replace=False)
Xa = Xa[indices]
Ya = Ya[indices]

if not isinstance(Xa, pd.DataFrame):
    Xa = pd.DataFrame(Xa)

Xa = Xa.to_numpy()
#Ya= Ya.to_numpy()

print(Xa.shape)

import numpy as np

# Comprovació de la forma
print("Forma de X:", Xa.shape)
print("Forma de Y:", Ya.shape)

# Comprovació del contingut
print("\nDades d'exemple de X (primers dos mostres):")
print(Xa[:2])
print("\nDades corresponents de Y (primers dos mostres):")
print(Ya[:2])

# Comprovació del tipus de dades
print("\nTipus de dades de X:", Xa.dtype)
print("Tipus de dades de Y:", Ya.dtype)

# Comprovació de consistència- primeres dades
print("\nVerificant la primera mostra:")
print("Dades de X (primera mostra):", Xa[0])
print("Dades de Y (corresponents a la primera mostra):", Ya[0])

# Resum estadístic
print("\nResum estadístic de X:")
print("Mitjana:", np.mean(Xa, axis=0))
print("Desviació estàndard:", np.std(Xa, axis=0))

print("\nResum estadístic de Y:")
print("Mitjana:", np.mean(Ya))
print("Desviació estàndard:", np.std(Ya))

"""##Algorismes Geràrquics"""

from scipy.cluster.hierarchy import linkage

# Creació de les etiquetes a partir dels índexs del DataFrame
labels = [f'Punt {i}' for i in range(len(data_ag))]

import pandas as pd
from scipy.spatial.distance import pdist, squareform
row_dist = pd.DataFrame(squareform(pdist(data_ag, metric='euclidean')),
                        columns=labels,
                        index=labels)

print(row_dist)

# Condensar matriu
row_clusters = linkage(pdist(data_ag, metric='euclidean'), method='complete')
pd.DataFrame(row_clusters,
              columns=['Etiqueta fila 1', 'Etiqueta fila 2', 'Distància', 'Núm. d’elements al clúster'],
             index=['cluster %d' % (i + 1) for i in range(row_clusters.shape[0])]
             )

from scipy.cluster.hierarchy import dendrogram
# Creació del DataFrame per als clústers
df_clusters = pd.DataFrame(row_clusters,
                           columns=['Etiqueta fila 1', 'Etiqueta fila 2', 'Distància', 'Núm. d’elements al clúster'],
                           index=['clúster %d' % (i + 1) for i in range(row_clusters.shape[0])])

# Creació i visualització del dendrograma
row_dendr = dendrogram(row_clusters, labels=labels)
plt.tight_layout()
plt.ylabel('Distància Euclidiana')
plt.show()

"""###Clusters aglomeratius"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans

# Convertir el DataFrame a la matriu de característiques 'X' i el vector d'etiquetes 'Y'
#X =Xa
#Y = Ya

# Paràmetres inicials
random_state = 170
n_samples = 1500
plt.figure(figsize=(16, 16))

# Utilitzar K-means per trobar els centres dels clústers amb k elevada
kmeans = KMeans(n_clusters=3, random_state=random_state)
kmeans.fit(Xa)
centers = kmeans.cluster_centers_


# Tipus d'enllaç per a l'agrupació aglomerativa
linkage_types = ['single','complete', 'average', 'ward']

n_rows, n_cols = 2, 2  # Defineix 2 files i 2 columnes

for i, linkage in enumerate(linkage_types, start=1):
    # Aplicar agrupació aglomerativa

    agg_cluster = AgglomerativeClustering(n_clusters=3, linkage=linkage)
    y_pred = agg_cluster.fit_predict(Xa)

    # Visualitzar els resultats
    plt.subplot(n_rows, n_cols, i)

    plt.scatter(Xa[:, 0], Xa[:, 1], c=y_pred)
    plt.title(f"Aglomeratiu - Enllaç {linkage.capitalize()}")

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from scipy.cluster.hierarchy import dendrogram, linkage

# Paràmetres inicials
random_state = 170
n_samples = 1500

# Utilitzar K-means per trobar els centres dels clústers amb k elevada
kmeans = KMeans(n_clusters=3, random_state=random_state)
kmeans.fit(Xa)

# Tipus d'enllaç per a l'agrupació aglomerativa
linkage_types = ['single','complete', 'average', 'ward']

# Crear una nova figura per als dendrogramas
plt.figure(figsize=(12, 12))

for i, linkage_type in enumerate(linkage_types, start=1):
    # Calcular el linkage per a cada tipus
    linked = linkage(Xa, method=linkage_type)

    # Visualitzar els resultats en un dendrograma
    plt.subplot(2, 2, i)
    dendrogram(linked, truncate_mode='lastp', p=50)  # Mostra només les últimes 50 fusió
    plt.title(f"Dendrograma - {linkage_type.capitalize()}")
    plt.xlabel('Índex de la Mostra')
    plt.ylabel('Distància')

plt.tight_layout()
plt.show()

"""###Clusters aglomeratius sobre els centres"""

#carregar dades del DRIVE
from google.colab import drive

#from google.colab import drive -demana permis a llegir el DRIVE
drive.mount('/content/drive')
data_ac = pd.read_csv('drive/My Drive/MIDA/company-stock-movements-2010-2015-incl.csv',sep=',')

print(data_ac.shape)
data_ac.head()

#Crear set de dades
#No calen noms de les empreses
data_ac = data_ac.drop(['Unnamed: 0'], axis=1)

data_float = data_ac.astype(float).T

#inicalitzar
X_ac= []
Y_ac = []

# Bucle per cada companyia
for company in data_float.columns:
    # Bucle per el dataframe amb la finestra de 6DIES
    for i in range(len(data_float) - 6):
        X_ac.append(data_float[company].iloc[i:i+5].values)  # 5 DIES
        Y_ac.append(data_float[company].iloc[i+5])          # 6 DIES

X_ac = np.array(X_ac)
Y_ac = np.array(Y_ac)

print(X_ac.shape)

import numpy as np
frac = 0.4  # Change 0.1 to the fraction you desire

indices = np.random.choice(X_ac.shape[0], size=int(X_ac.shape[0] * frac), replace=False)
X_ac = X_ac[indices]
Y_ac = Y_ac[indices]

if not isinstance(Xa, pd.DataFrame):
    Xa = pd.DataFrame(Xa)

#X_ac = X_ac.to_numpy()
#Ya= Ya.to_numpy()

print(X_ac.shape)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from sklearn.cluster import KMeans
import pandas as pd

# Convertir el DataFrame a la matriu de característiques 'X' i el vector d'etiquetes 'Y'
#X =X_ac
#Y = Y_ac

# Paràmetres inicials
random_state = 170
n_clusters = 20  # nombre elevat de clústers per K-means

# Utilitzar K-means per trobar els centres dels clústers amb k elevada
kmeans = KMeans(n_clusters=n_clusters, random_state=random_state)
kmeans.fit(X_ac)
centers = kmeans.cluster_centers_

# Tipus d'enllaç per a l'agrupació aglomerativa
linkage_types = ['single','complete', 'average', 'ward']

# Configuració de la figura
plt.figure(figsize=(16, 16))
n_rows, n_cols = 2, 2  # Definim una graella de 2x2 per als gràfics

for i, linkage in enumerate(linkage_types, start=1):
    # Aplicar agrupació aglomerativa als centres de K-means
    agg_cluster = AgglomerativeClustering(n_clusters=3, linkage=linkage)
    agg_cluster.fit(centers)

    # Assignar les etiquetes de clúster aglomeratiu a cada punt del conjunt de dades
    labels = agg_cluster.labels_
    y_pred = np.choose(kmeans.labels_, labels)

    # Visualitzar els resultats
    plt.subplot(n_rows, n_cols, i)
    plt.scatter(X_ac[:, 0], X_ac[:, 1], c=y_pred, cmap='viridis')
    plt.scatter(centers[:, 0], centers[:, 1], c='red', s=50, marker='x')  # Centres com a punts vermells
    plt.title(f"Aglomeratiu - Enllaç {linkage.capitalize()}")
    plt.xlabel('Característica 1')
    plt.ylabel('Característica 2')

plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import AgglomerativeClustering
from sklearn.datasets import make_blobs
from sklearn.cluster import KMeans
from scipy.cluster.hierarchy import dendrogram, linkage

# Convertir el DataFrame a la matriu de característiques 'X' i el vector d'etiquetes 'Y'
#X =X_ac
#Y = Y_ac

# Paràmetres inicials
random_state = 170
n_samples = 1500

# Utilitzar K-means per trobar els centres dels clústers amb k elevada
kmeans = KMeans(n_clusters=n_clusters, random_state=random_state)
kmeans.fit(X_ac)
centers = kmeans.cluster_centers_

# Tipus d'enllaç per a l'agrupació aglomerativa
linkage_types = ['single','complete', 'average', 'ward']

# Crear una figura per a visualitzar els dendrogramas
plt.figure(figsize=(16, 16))

for i, linkage_type in enumerate(linkage_types, start=1):
    # Calcular el linkage
    linked = linkage(centers, method=linkage_type)

    # Visualitzar el dendrograma per a cada tipus d'enllaç
    plt.subplot(2, 2, i)
    dendrogram(linked)
    plt.title(f"Dendrograma - Enllaç {linkage_type.capitalize()}")
    plt.xlabel('Índex del Centre')
    plt.ylabel('Distància')

plt.tight_layout()
plt.show()

"""### DBScan"""

#carregar dades del DRIVE
from google.colab import drive

#from google.colab import drive -demana permis a llegir el DRIVE
drive.mount('/content/drive')
data_d = pd.read_csv('drive/My Drive/MIDA/company-stock-movements-2010-2015-incl.csv',sep=',')

print(data_d.shape)
data_d.head()

#Crear set de dades
#No calen noms de les empreses
data_d = data_d.drop(['Unnamed: 0'], axis=1)

data_float = data_d.astype(float).T

#inicalitzar
Xd = []
Yd = []

# Bucle per cada companyia
for company in data_float.columns:
    # Bucle per el dataframe amb la finestra de 6DIES
    for i in range(len(data_float) - 6):
        Xd.append(data_float[company].iloc[i:i+5].values)  # 5 DIES
        Yd.append(data_float[company].iloc[i+5])          # 6 DIES
Xd = np.array(Xd)
Yd = np.array(Yd)
print(Xd.shape)

import numpy as np
frac = 0.4  # Change 0.1 to the fraction you desire

indices = np.random.choice(Xd.shape[0], size=int(Xd.shape[0] * frac), replace=False)
Xd = Xd[indices]
Yd = Yd[indices]

if not isinstance(Xd, pd.DataFrame):
    Xd = pd.DataFrame(Xd)

#X_ac = X_ac.to_numpy()
#Ya= Ya.to_numpy()

print(Xd.shape)

"""Millors paràmetres"""

from sklearn.neighbors import NearestNeighbors
import numpy as np
import matplotlib.pyplot as plt
#Optim eps
k = 4
nearest_neighbors = NearestNeighbors(n_neighbors=k).fit(Xd)
distances, _ = nearest_neighbors.kneighbors(Xd)

# ordena distancies
sorted_distances = np.sort(distances[:, k-1])

plt.plot(sorted_distances)
plt.xlabel('Punts')
plt.ylabel('Distancia a kkn vei')
plt.title('KKN Distancia')
plt.show()

import numpy as np

from sklearn.metrics.pairwise import pairwise_distances
from scipy.spatial.distance import pdist, squareform
#Optim kcloser
distances=squareform(pdist(Xd))

kcloser = 3
lkthc = [np.sort(x)[kcloser+1] for x in distances]

from sklearn.cluster import DBSCAN
import matplotlib.pyplot as plt
import numpy as np


# Converteix Xd a un array de NumPy
Xd_np = Xd.to_numpy()

#kcloser = 3

db = DBSCAN(eps=0.23, min_samples=kcloser, metric='euclidean')
y_db = db.fit_predict(Xd_np)

# Obtenir les etiquetes úniques i generar colors per a cada clúster
unique_labels = np.unique(y_db)
colors = plt.cm.Spectral(np.linspace(0, 1, len(unique_labels)))

for k, col in zip(unique_labels, colors):
    if k == -1:
        # Color blanc utilitzat per a soroll.
        col = 'white'
    else:
        col = col

    class_member_mask = (y_db == k)

    # Plotejar els punts per a cada clúster
    plt.scatter(Xd_np[class_member_mask, 0], Xd_np[class_member_mask, 1], c=[col], marker='o', s=40, edgecolor='black', label='cluster '+str(k))

plt.title('DBScan')
plt.show()